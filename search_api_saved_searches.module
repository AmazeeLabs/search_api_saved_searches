<?php

/**
 * @file
 * Offers the ability to save searches and be notified of new results.
 */

/**
 * Implements hook_menu().
 */
function search_api_saved_searches_menu() {
  $items['admin/config/search/search_api/index/%search_api_index/saved_searches'] = array(
    'title' => 'Saved searches',
    'description' => 'Let users saves searches on this index.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_saved_searches_index_edit', 5),
    'access arguments' => array('administer search_api_saved_searches'),
    'weight' => -1,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE | MENU_CONTEXT_PAGE,
    'file' => 'search_api_saved_searches.admin.inc',
  );
  $items['user/%user/saved-searches'] = array(
    'title' => 'Saved searches',
    'description' => 'View and edit your saved searches.',
    'page callback' => 'search_api_saved_searches_user_listing',
    'page arguments' => array(1),
    'access callback' => 'search_api_saved_search_edit_access',
    'access arguments' => array(1),
    'weight' => 5,
    'type' => MENU_LOCAL_TASK,
    'file' => 'search_api_saved_searches.pages.inc',
  );
  $items['search-api/saved-search/%search_api_saved_search/activate/%'] = array(
    'title' => 'Activate saved search',
    'description' => 'Activate a new saved search.',
    'page callback' => 'search_api_saved_searches_activate_page',
    'page arguments' => array(2, 4),
    'access callback' => 'search_api_saved_search_edit_access',
    'access arguments' => array(NULL, 2, 4),
    'file' => 'search_api_saved_searches.pages.inc',
  );
  // @todo Edit?
  $items['search-api/saved-search/%search_api_saved_search/delete'] = array(
    'title' => 'Activate saved search',
    'description' => 'Activate a new saved search.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_saved_searches_search_delete_form', 2),
    'access callback' => 'search_api_saved_search_edit_access',
    'access arguments' => array(NULL, 2, 4),
    'file' => 'search_api_saved_searches.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_permission();
 */
function search_api_saved_searches_permission() {
  $perms['administer search_api_saved_searches'] = array(
    'title' => t('Administer saved searches'),
    'description' => t('Enable and configure saved searches for search indexes.'),
  );
  $perms['use search_api_saved_searches'] = array(
    'title' => t('Use saved searches'),
    'description' => t('Save searches and receive e-mail notifications.'),
  );
  return $perms;
}

/**
 * Implements hook_entity_info().
 */
function search_api_saved_searches_entity_info() {
  $info['search_api_saved_searches_settings'] = array(
    'label' => t('Saved search settings'),
    'controller class' => 'EntityAPIController',
    'entity class' => 'SearchApiSavedSearchesSettings',
    'base table' => 'search_api_saved_searches_settings',
    'uri callback' => 'search_api_saved_searches_settings_url',
    'module' => 'search_api_saved_searches',
    'exportable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'name' => 'delta',
    ),
  );
  $info['search_api_saved_search'] = array(
    'label' => t('Saved search'),
    'controller class' => 'EntityAPIController',
    'entity class' => 'SearchApiSavedSearch',
    'base table' => 'search_api_saved_search',
    'module' => 'search_api_saved_searches',
    'exportable' => FALSE,
    'entity keys' => array(
      'id' => 'id',
      'label' => 'name',
    ),
  );

  return $info;
}

/**
 * URL callback for settings entities.
 */
function search_api_saved_searches_settings_url(SearchApiSavedSearchesSettings $settings) {
  return array('path' => 'admin/config/search/search_api/index/' . $settings->index_id . '/saved_searches');
}

// @todo Implement hook_user_*() to automatically assign new users all saved
//   searches with their mail address after registration (and free it again if
//   the user is deleted).

/**
 * Implements hook_search_api_index_update().
 *
 * If the index got disabled, do the same with its search settings.
 */
function search_api_saved_searches_search_api_index_update(SearchApiIndex $index) {
  if (!$index->enabled && $index->original->enabled) {
    foreach (search_api_saved_searches_settings_load_multiple(FALSE, array('index_id' => $index->machine_name)) as $settings) {
      if ($settings->enabled) {
        $settings->enabled = FALSE;
        $settings->save();
      }
    }
  }
}

/**
 * Implements hook_search_api_index_delete().
 *
 * Deletes the settings associated with a search index.
 */
function search_api_saved_searches_search_api_index_delete(SearchApiIndex $index) {
  foreach (search_api_saved_searches_settings_load_multiple(FALSE, array('index_id' => $index->machine_name)) as $settings) {
    $settings->delete();
  }
}

/**
 * Implements hook_search_api_saved_searches_settings_insert().
 *
 * Clear block caches when new enabled saved search settings are saved.
 */
function search_api_saved_searches_search_api_saved_searches_settings_insert(SearchApiSavedSearchesSettings $settings) {
  if ($settings->enabled) {
    block_flush_caches();
    cache_clear_all('*', 'cache_block', TRUE);
  }
}

/**
 * Implements hook_search_api_saved_searches_settings_update().
 *
 * Clear block caches when saved search settings are enabled or disabled.
 */
function search_api_saved_searches_search_api_saved_searches_settings_update(SearchApiSavedSearchesSettings $settings) {
  if ($settings->enabled != $settings->original->enabled) {
    block_flush_caches();
    cache_clear_all('*', 'cache_block', TRUE);
  }
}

/**
 * Implements hook_search_api_saved_searches_settings_delete().
 *
 * Clear block caches when enabled saved search settings are deleted.
 */
function search_api_saved_searches_search_api_saved_searches_settings_delete(SearchApiSavedSearchesSettings $settings) {
  foreach (search_api_saved_search_load_multiple(FALSE, array('settings_id' => $settings->delta)) as $search) {
    $search->delete();
  }
  if ($settings->enabled) {
    block_flush_caches();
    cache_clear_all('*', 'cache_block', TRUE);
  }
}

/**
 * Loads a single settings object.
 *
 * @param $id
 *   The settings' identifier or delta.
 * @param $reset
 *   If TRUE, will reset the internal entity cache.
 *
 * @return SearchApiSavedSearchesSettings
 *   The requested entity, or FALSE if no settings for that ID exist.
 */
function search_api_saved_searches_settings_load($id, $reset = FALSE) {
  $ret = entity_load('search_api_saved_searches_settings', array($id), array(), $reset);
  return $ret ? reset($ret) : FALSE;
}

/**
 * Loads multiple settings objects.
 *
 * @param $ids
 *   The settings' identifiers or deltas; or FALSE to load all settings objects.
 * @param array $conditions
 *   Associative array of field => value conditions that returned objects must
 *   satisfy.
 * @param $reset
 *   If TRUE, will reset the internal entity cache.
 *
 * @return array
 *   An array of SearchApiSavedSearchesSettings objects matching the conditions.
 */
function search_api_saved_searches_settings_load_multiple($ids = FALSE, array $conditions = array(), $reset = FALSE) {
  return entity_load('search_api_saved_searches_settings', $ids, $conditions, $reset);
}

/**
 * Loads a single saved search object.
 *
 * @param $id
 *   The saved search's ID.
 * @param $reset
 *   If TRUE, will reset the internal entity cache.
 *
 * @return SearchApiSavedSearch
 *   The requested entity, or FALSE if no settings for that ID exist.
 */
function search_api_saved_search_load($id, $reset = FALSE) {
  $ret = entity_load('search_api_saved_search', array($id), array(), $reset);
  return $ret ? reset($ret) : FALSE;
}

/**
 * Loads multiple saved search objects.
 *
 * @param $ids
 *   The saved search's IDs; or FALSE to load all saved searches.
 * @param array $conditions
 *   Associative array of field => value conditions that returned objects must
 *   satisfy.
 * @param $reset
 *   If TRUE, will reset the internal entity cache.
 *
 * @return array
 *   An array of SearchApiSavedSearch objects matching the conditions.
 */
function search_api_saved_search_load_multiple($ids = FALSE, array $conditions = array(), $reset = FALSE) {
  return entity_load('search_api_saved_search', $ids, $conditions, $reset);
}

/**
 * Determine whether the current user can create a saved search for specific settings.
 *
 * @param SearchApiSavedSearchesSettings $settings
 *   The settings to check for.
 *
 * @return boolean
 *   TRUE iff the current user is allowed to create a new saved search.
 */
function search_api_saved_search_create_access(SearchApiSavedSearchesSettings $settings) {
  if (!$settings->enabled) {
    return FALSE;
  }

  if (user_access('administer search_api_saved_searches')) {
    return TRUE;
  }
  if (!user_access('use search_api_saved_searches')) {
    return FALSE;
  }

  // @todo Check settings-specific access rules, when there are any.

  return TRUE;
}

/**
 * Determine access to the edit interface for saved searches of a given user.
 *
 * This is both used to determine whether the current user can edit a specific
 * saved search, or whether she can display the overview of the user's saved
 * searches.
 * For anonymous users' searches an access key is generated that allows
 * accessing and editing the searches.
 *
 * @param $account
 *   (optional) The user whose saved search(es) would be edited. NULL for guest.
 * @param SearchApiSavedSearch $search
 *   (optional) The saved search involved, if there is just a single one.
 * @param string $key
 *   (optional) The saved search involved, if there is just a single one.
 *
 * @return boolean
 *   TRUE iff the current user is allowed to edit the saved search(es).
 */
function search_api_saved_search_edit_access($account, SearchApiSavedSearch $search = NULL, $key = NULL) {
  global $user;

  if (!isset($account)) {
    if (!isset($search)) {
      return FALSE;
    }
    $account = (object) array('uid' => $search->uid);
  }

  if (user_access('administer search_api_saved_searches')) {
    return TRUE;
  }
  // Barring admins, the only way to edit anonymous users' saved searches is by
  // providing the access key. There is no overview of all saved searches.
  if ($account->uid == 0) {
    if (empty($search) || empty($key)) {
      return FALSE;
    }
    return isset($search->options['key']) && $search->options['key'] == $key;
  }
  if ($account->uid != $user->uid || !user_access('use search_api_saved_searches')) {
    return FALSE;
  }
  if (isset($search) && $search->uid != $account->uid) {
    return FALSE;
  }
  if (!isset($search)) {
    // We only let the user view the listing if there are any saved searches.
    // @todo Also allow access if saved searches can be created freely.
    $select = db_select('search_api_saved_search', 's')
      ->condition('uid', $account->uid);
    $select->addExpression('COUNT(1)');
    if (!$select->execute()->fetchField()) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Implements hook_block_info().
 */
function search_api_saved_searches_block_info() {
  $blocks = array();
  foreach (search_api_saved_searches_settings_load_multiple(FALSE, array('enabled' => TRUE)) as $settings) {
    try {
      $blocks[$settings->delta] = array(
        'info' => t('!index: Save search', array('!index' => $settings->index()->name)),
        // @todo Is this cache setting correct?
        'cache' => DRUPAL_CACHE_PER_ROLE | DRUPAL_CACHE_PER_PAGE,
      );
    }
    catch (SearchApiException $e) {}
  }
  return $blocks;
}

/**
 * Implements hook_block_configure().
 */
function search_api_saved_searches_block_configure($delta = '') {
  $settings = search_api_saved_searches_settings_load($delta);
  $form['settings_link'] = array(
    '#markup' => l(t('To saved search settings'), 'admin/config/search/search_api/index/' . $settings->index_id . '/saved_searches'),
  );
  return $form;
}

/**
 * Implements hook_block_view().
 */
function search_api_saved_searches_block_view($delta = '') {
  $searches = search_api_current_search();
  if (!$searches) {
    return;
  }
  if (!user_access('use search_api_saved_searches')) {
    return;
  }
  $settings = search_api_saved_searches_settings_load($delta);
  if (!$settings || !search_api_saved_search_create_access($settings)) {
    return;
  }
  $index_id = $settings->index_id;
  $options = $settings->options;
  $ids_list = drupal_map_assoc($options['ids_list']);
  $search_ids = variable_get('search_api_saved_searches_search_ids', array());
  foreach ($searches as $id => $data) {
    if ($data[0]->getIndex()->machine_name == $index_id){
      if (!isset($search_ids[$index_id][$id])) {
        $search_ids[$index_id][$id] = $id;
        $search_ids_updated = TRUE;
      }
      if (isset($ids_list[$id]) != $options['default_true']) {
        if (isset($query)) {
          watchdog('search_api_saved_searches', 'Two matching searches on index %index for saved search block.',
              array('%index' => $settings->index()->name), WATCHDOG_WARNING,
              l(t('view page'), $_GET['q'], array('query' => drupal_get_query_parameters())));
        }
        else {
          list($query, $results) = $data;
        }
      }
    }
  }
  if (isset($search_ids_updated)) {
    variable_set('search_api_saved_searches_search_ids', $search_ids);
  }
  if (empty($query)) {
    return;
  }

  return array(
    'subject' => t('Save search'),
    'content' => drupal_get_form('search_api_saved_searches_save_form', $settings, $query),
  );
}

/**
 * Form builder for creating a new saved search.
 *
 * @param SearchApiSavedSearchesSettings $settings
 *   The saved search settings with which to create a new saved search.
 * @param SearchApiQueryInterface $query
 *   (optional) If creating a saved search for an already executed query, the
 *   query.
 *
 * @see search_api_saved_searches_save_form_validate()
 * @see search_api_saved_searches_save_form_submit()
 * @ingroup forms
 */
function search_api_saved_searches_save_form(array $form, array &$form_state, SearchApiSavedSearchesSettings $settings, SearchApiQueryInterface $query = NULL) {
  global $user;

  if (!isset($form_state['query']) && isset($query)) {
    $form_state['query'] = array(
      'index_id' => $query->getIndex()->machine_name,
      'keys' => $query->getKeys(),
      'original_keys' => $query->getOriginalKeys(),
      'fields' => $query->getFields(),
      'filters' => $query->getFilter()->getFilters(),
      'options' => $query->getOptions(),
    );
    $form_state['query']['options']['search id'] = $settings->delta . ':' . 'saved-search';
  }
  $form_state['settings'] = $settings;

  // @todo if (empty($form_state['query'])) -> provide advanced creation form.

  $form['#prefix'] = '<div id="search-api-saved-searches-save-form-wrapper">';
  $form['#suffix'] = '</div>';
  $form['name'] = array(
    '#type' => 'value',
    '#value' => _search_api_saved_searches_create_name($form_state['query']),
  );
  if (empty($user->mail) || $settings->options['registered_choose_mail']) {
    $form['mail'] = array(
      '#type' => 'textfield',
      '#title' => t('E-mail address'),
      '#maxlength' => 100,
      '#size' => 16,
      '#default_value' => isset($user->mail) ? $user->mail : '',
      '#required' => TRUE,
    );
  }
  else {
    $form['mail'] = array(
      '#type' => 'value',
      '#value' => $user->mail,
    );
  }

  if ($settings->options['user_select_interval'] && count($settings->options['interval_options']) > 1) {
    $form['notify_interval'] = array(
      '#type' => 'select',
      '#title' => t('Notification interval'),
      '#options' => $settings->options['interval_options'],
      '#required' => TRUE,
    );
  }
  else {
    $form['notify_interval'] = array(
      '#type' => 'value',
      '#value' => $settings->options['user_select_interval'] ? reset($settings->options['interval_options']) : $settings->options['set_interval'],
    );
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save search'),
    '#ajax' => array(
      'callback' => 'search_api_saved_searches_save_form_ajax',
      'wrapper' => 'search-api-saved-searches-save-form-wrapper',
      'effect' => 'fade',
      'method' => 'replace',
    ),
    '#executes_submit_callback' => TRUE,
  );

  return $form;
}

/**
 * AJAX submit handler for search_api_saved_searches_save_form().
 */
function search_api_saved_searches_save_form_ajax(array $form, array &$form_state) {
  return form_get_errors() ? $form : array('#theme' => 'status_messages');
}

/**
 * Form validation handler for search_api_saved_searches_save_form().
 *
 * @see search_api_saved_searches_save_form()
 * @see search_api_saved_searches_save_form_submit()
 */
function search_api_saved_searches_save_form_validate(array $form, array &$form_state) {
  if ($msg = user_validate_mail($form_state['values']['mail'])) {
    form_error($form['mail'], $msg);
  }
}

/**
 * Form validation handler for search_api_saved_searches_save_form().
 *
 * @param $message
 *   (optional) Whether to set a message reporting success or failure.
 *
 * @return boolean
 *   TRUE iff the search was successfully saved.
 *
 * @see search_api_saved_searches_save_form()
 * @see search_api_saved_searches_save_form_validate()
 */
function search_api_saved_searches_save_form_submit(array $form, array &$form_state, $message = TRUE) {
  global $user;
  $values = $form_state['values'];
  $query = array_intersect_key($form_state['query'], drupal_map_assoc(array('keys', 'fields', 'filters', 'options')));

  $search = new SearchApiSavedSearch(array(
    'uid' => $user->uid,
    'settings_id' => $form_state['settings']->id,
    'enabled' => $user->mail == $values['mail'] || user_access('administer search_api_saved_searches'),
    'name' => $values['name'],
    'mail' => $values['mail'],
    'created' => REQUEST_TIME,
    'last_execute' => REQUEST_TIME,
    'notify_interval' => $values['notify_interval'],
    'query' => $query,
    'options' => array(
      'page' => array(
        'path' => $_GET['q'],
        'query' => drupal_get_query_parameters(),
      ),
    ),
  ));
  if (!$search->enabled && $user->uid) {
    if (search_api_saved_search_load_multiple(FALSE, array('enabled' => TRUE, 'uid' => $user->uid, 'mail' => $search->mail))) {
      $search->enabled = TRUE;
    }
  }
  $ret = $search->save();
  $form_state['redirect'] = array($_GET['q'], array('query' => drupal_get_query_parameters()));
  if (!$ret) {
    drupal_set_message(t('An error occurred while trying to save the search. Please contact the site administrator.'), 'error');
    $form_state['rebuild'] = TRUE;
    return FALSE;
  }
  else {
    if ($search->enabled) {
      drupal_set_message(t('Your saved search was successfully created. You will receive e-mail notifications for new results in the future.'));
    }
    else {
      drupal_set_message(t('Your saved search was successfully created. You will soon receive an e-mail with a confirmation link to activate it.'));
    }
    return TRUE;
  }
}

/**
 * Helper function for creating a name for a saved search with the given query.
 */
function _search_api_saved_searches_create_name(array $query) {
  if (!empty($query['original_keys'])) {
    $ret[] = $query['original_keys'];
  }
  // @todo File through filters, looking for things that could go in a name.

  return isset($ret) ? implode(' / ', $ret) : t('Saved search');
}

/**
 * Implements hook_mail().
 */
function search_api_saved_searches_mail($key, array &$message, array $params) {
  switch ($key) {
    case 'activate':
      $search = $params['search'];
      $settings = $search->settings();
      $data = array(
        'user' => $params['user'],
        'search_api_saved_search_info' => array(
          'search' => $search,
          'results' => array(),
        ),
      );
      $title = $settings->options['mail']['activate']['title'];
      $message['subject'] .= token_replace($title, $data, array('language' => $language, 'sanitize' => FALSE));
      $body = $settings->options['mail']['activate']['body'];
      $message['body'][] = token_replace($body, $params, array('language' => $language, 'sanitize' => FALSE));
      break;

    case 'notify':
      $settings = $params['settings'];
      $data = array(
        'user' => $params['user'],
        'search_api_saved_searches' => $params['searches'],
      );
      $title = $settings->options['mail']['notify']['title'];
      $message['subject'] .= token_replace($title, $data, array('language' => $language, 'sanitize' => FALSE));
      $body = $settings->options['mail']['notify']['body'];
      $message['body'][] = token_replace($body, $params, array('language' => $language, 'sanitize' => FALSE));
      break;
  }
}
